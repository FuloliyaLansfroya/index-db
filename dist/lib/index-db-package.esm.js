const e=Symbol("create"),t=Symbol("reset");class r{constructor(e){this.dbName=e,this.db=null,this.version=1,this.isOpen=!1}open(){return new Promise(((e,t)=>{const r=window.indexedDB.open(this.dbName);r.onsuccess=t=>{this.db=t.target.result;0===this.db.objectStoreNames.length?(this.db&&this.db.close(),window.indexedDB.deleteDatabase(this.dbName),this.version=1,e(this.db),this.db=null):(this.version=this.db.version,e(this.db)),this.isOpen=!0},r.onerror=()=>{t(Error("Why didn't you allow my web app to use IndexedDB?!"))}}))}close(){if(!this.isOpen)throw Error("The database is not open, this method cannot be used!");this.db&&this.db.close(),this.isOpen=!1}deleteDatabase(){if(!this.isOpen)throw Error("The database is not open, this method cannot be used!");this.db&&this.db.close(),window.indexedDB.deleteDatabase(this.dbName),this[t]()}[t](){this.dbName="",this.db=null,this.version=1,this.isOpen=!1}createDataSheet(t){return new Promise(((r,o)=>{if(!this.isOpen)return void o(Error("The database is not open, this method cannot be used!"));for(let e=0;e<t.length;e++){const{storeName:r,createType:s,DBType:n="",primaryKey:i=""}=t[e];if("automatic"===s);else{if("manual"!==s)return void o(Error(`Entered create type '${s}' is wrong value!`));if(!n||!i)return void o(Error("Entered create type is manual, but Other required parameters are empty!"))}if(this.db&&this.db.objectStoreNames.contains(r))return void o(Error(`data table ${r} to be created already exists`))}this.version+=1,this.db&&this.db.close();const s=window.indexedDB.open(this.dbName,this.version);this[e](s,t,o),s.onsuccess=e=>{this.db=e.target.result,r("success")},s.onerror=()=>{o(Error("Why didn't you allow my web app to use IndexedDB?!"))}}))}[e](e,t,r){e&&(e.onupgradeneeded=function(e){const r=e.target.result;t.forEach((e=>{const{storeName:t,createType:o,indexArr:s=[],DBType:n="",primaryKey:i=""}=e;if(!r.objectStoreNames.contains(t))if("automatic"===o)r.createObjectStore(t,{autoIncrement:!0});else if("manual"===o){const e=r.createObjectStore(t,{keyPath:i});s&&s.length&&s.forEach((t=>{e.createIndex(t.key,t.key,{unique:t.unique})})),e.transaction.oncomplete=function(){r.transaction(t,n).objectStore(t)}}}))})}set(e,t){return new Promise(((r,o)=>{if(this.isOpen)if(this.db.objectStoreNames.contains(e)){const s=this.db.transaction([e],"readwrite"),n=s.objectStore(e);t.forEach((function(e){n.put(e).onsuccess=function(){}})),s.oncomplete=function(){r(s)},s.onerror=function(){o(Error("An error occurred during this operation, please check whether the parameters are correct!"))}}else o(Error(`data table ${e} is not create`));else o(Error("The database is not open, this method cannot be used!"))}))}delete(e,t){return new Promise(((r,o)=>{if(this.isOpen)if(this.db.objectStoreNames.contains(e)){const s=this.db.transaction([e],"readwrite");s.objectStore(e).delete(t),s.onsuccess=function(){r(s)},s.onerror=function(){o(Error("An error occurred during this operation, please check whether the parameters are correct!"))}}else o(Error(`data table ${e} is not create`));else o(Error("The database is not open, this method cannot be used!"))}))}deleteObjectStore(e){return new Promise(((t,r)=>{if(this.isOpen)if(this.db.objectStoreNames.contains(e)){this.version+=1,this.db&&this.db.close();const o=window.indexedDB.open(this.dbName,this.version);o.onsuccess=e=>{this.db=e.target.result,t("success")},o.onupgradeneeded=function(t){t.target.result.deleteObjectStore(e)},o.onerror=()=>{r(Error("Why didn't you allow my web app to use IndexedDB?!"))}}else r(Error(`data table ${e} is not create`));else r(Error("The database is not open, this method cannot be used!"))}))}search(e,t,r,o=!1){return new Promise(((s,n)=>{if(this.isOpen)if(r=r.toString().toLocaleLowerCase(),this.db.objectStoreNames.contains(e)){const i=this.db.transaction([e]),a=i.objectStore(e),c=[];a.openCursor().onsuccess=function(i){const a=i.target.result;if(a){a.value[t]||n(Error(`There is no '${t}' index in the '${e}' data table, please check whether the value of the data is correct!`));const s=a.value[t]&&a.value[t].toString().toLocaleLowerCase();(o&&s.includes(r)||!o&&s===r)&&c.push(a.value),a.continue()}else s(c)},i.onerror=function(){n(Error("An error occurred during this operation, please check whether the parameters are correct!"))}}else n(Error(`data table ${e} is not create`));else n(Error("The database is not open, this method cannot be used!"))}))}getOfKeyRange(e,t,r){return new Promise(((o,s)=>{if(this.isOpen)if(this.db.objectStoreNames.contains(e)){const n=this.db.transaction([e]),i=[],a=n.objectStore(e);(r?a.openCursor(t,r):a.openCursor(t)).onsuccess=function(e){const t=e.target.result;t?(i.push(t.value),t.continue()):o(i)},n.onerror=function(){s(Error("An error occurred during this operation, please check whether the parameters are correct!"))}}else s(Error(`data table ${e} is not create`));else s(Error("The database is not open, this method cannot be used!"))}))}updata(e,t,r,o){return new Promise(((s,n)=>{if(this.isOpen)if(this.db.objectStoreNames.contains(e)){const i=this.db.transaction([e],"readwrite").objectStore(e),a=i.get(t);a.onerror=function(){n(Error("An error occurred during this operation, please check whether the parameters are correct!"))},a.onsuccess=function(e){const t=e.target.result;t[r]=o;const c=i.put(t);c.onerror=function(){n(Error("An error occurred during this operation, please check whether the parameters are correct!"))},c.onsuccess=function(){s(a.result)}}}else n(Error(`data table ${e} is not create`));else n(Error("The database is not open, this method cannot be used!"))}))}clear(e){return new Promise(((t,r)=>{if(this.isOpen)if(this.db.objectStoreNames.contains(e)){const o=this.db.transaction([e],"readwrite");o.objectStore(e).clear(),o.oncomplete=function(){t(o)},o.onerror=function(){r(Error("An error occurred during this operation, please check whether the parameters are correct!"))}}else r(Error(`data table ${e} is not create`));else r(Error("The database is not open, this method cannot be used!"))}))}}export{r as default};
